// Generated by CoffeeScript 1.6.1
(function() {
  var CLOUD, CROSS, CustomRandom, LINE, POOL, attrStr, attrib, buildingGroup, cachedRandomConstant, cachedRandomMaximum, cityGroup, curLinkIndex, darkBackground, darkBlueGreen, darkForestGreen, darkerBlueGreen, defaultStart, dullBlue, dullGrey, dullYellow, forestGreen, forestWoods, getPointAlignedToGrid, getRectsIn, growSeed, hash, indexSizeTable, layerGroups, linkPath, mBackground, mBlack, mBlue, mGrey, mRed, mYellow, outerGroup, peopleGroup, recallCellProperty, rememberCellProperty, sageStreak, start, tiles, veryDarkYellow, waterGroup;

  cachedRandomConstant = Math.pow(2, 13) + 1;

  cachedRandomMaximum = Math.pow(2, 50);

  CustomRandom = function(x, y, s) {
    var constant, maximum, nextfn, prime, seed, times, _i;
    constant = cachedRandomConstant;
    prime = 37;
    maximum = cachedRandomMaximum;
    x += 10000;
    y += 10000;
    x = Math.abs(x);
    y = Math.abs(y);
    seed = (x * y * 13 + 1) + ((y & x) * 13 + 1) + s;
    nextfn = function() {
      seed *= constant;
      seed += prime;
      seed %= maximum;
      return ~~(1024 * seed / maximum);
    };
    for (times = _i = 0; _i < 6; times = ++_i) {
      nextfn;
    }
    return {
      next: nextfn
    };
  };

  Number.prototype.mod = function(n) {
    return ((this % n) + n) % n;
  };

  getPointAlignedToGrid = function(x, y, s) {
    var gx, gy;
    gx = x - x.mod(s);
    gy = y - y.mod(s);
    return [gx, gy];
  };

  rememberCellProperty = function(map, x, y, s, k, v) {
    if (map[s] == null) {
      map[s] = {};
    }
    if (map[s][x] == null) {
      map[s][x] = {};
    }
    if (map[s][x][y] == null) {
      map[s][x][y] = {};
    }
    return map[s][x][y][k] = v;
  };

  recallCellProperty = function(map, x, y, s, k) {
    if ((map[s] != null) && (map[s][x] != null) && (map[s][x][y] != null)) {
      return map[s][x][y][k];
    } else {
      return void 0;
    }
  };

  indexSizeTable = {
    14: 8192,
    15: 16384,
    16: 32768,
    17: 65536,
    18: 131072
  };

  mYellow = '#f7bf00';

  dullYellow = '#dba300';

  mBlue = '#37508a';

  dullBlue = '#5b5c94';

  mRed = '#f50603';

  dullGrey = '#dfc4bd';

  mGrey = '#ded5d3';

  mBlack = '#291f20';

  mBackground = '#fcfffc';

  forestGreen = '#0b9600';

  darkForestGreen = '#006a02';

  darkBlueGreen = '#006a50';

  darkerBlueGreen = '#004d39';

  veryDarkYellow = '#243300';

  forestWoods = '#964e00';

  sageStreak = '#00ce91';

  darkBackground = '#0a4d00';

  LINE = 1;

  CROSS = 2;

  POOL = 3;

  CLOUD = 4;

  buildingGroup = [
    {
      index: 18,
      size: 131072,
      thresh: 25,
      grow: LINE,
      minDrawSize: 4,
      minstretch: 1,
      stretch: 3,
      colors: [mBlue, mRed, mYellow],
      outcolors: [forestWoods, forestGreen]
    }, {
      index: 17,
      size: 65536,
      thresh: 100,
      grow: LINE,
      minDrawSize: 8,
      minstretch: 1,
      stretch: 3,
      colors: [mRed, mYellow, mBlue, mGrey],
      outcolors: ['#000000']
    }
  ];

  cityGroup = [
    {
      index: 17,
      size: 65536,
      thresh: 100,
      grow: LINE,
      minDrawSize: 8,
      minstretch: 1,
      stretch: 2,
      colors: [mRed, mYellow, mBlue, mGrey]
    }, {
      index: 16,
      size: 32768,
      thresh: 100,
      grow: LINE,
      minDrawSize: 8,
      minstretch: 1,
      stretch: 3,
      colors: [mRed, mYellow, mBlue, mGrey]
    }, {
      index: 15,
      size: 16384,
      thresh: 7,
      grow: LINE,
      minDrawSize: 8,
      minstretch: 6,
      stretch: 7,
      colors: [mRed, mYellow, mBlue],
      outcolors: ['#FFFF00']
    }, {
      index: 14,
      size: 8192,
      thresh: 9,
      grow: LINE,
      minDrawSize: 8,
      minstretch: 22,
      stretch: 24,
      colors: [mRed, mYellow, mBlack, mBlue, mGrey],
      outcolors: ['#FFFF00']
    }
  ];

  peopleGroup = [
    {
      index: 11,
      size: 1024,
      thresh: 1,
      grow: CLOUD,
      minDrawSize: 4,
      minstretch: 1,
      cloudThresh: 40,
      stretch: 9,
      colors: ['#d8ad00', '#a68500', '#735c00', '#403300']
    }
  ];

  waterGroup = [
    {
      index: 28,
      size: 134217728,
      thresh: 30,
      grow: POOL,
      minDrawSize: 8,
      minstretch: 1,
      stretch: 4,
      colors: ['#7777ee']
    }, {
      index: 27,
      size: 67108864,
      thresh: 30,
      grow: POOL,
      minDrawSize: 8,
      minstretch: 1,
      stretch: 2,
      colors: ['#8888ee']
    }
  ];

  outerGroup = [
    {
      index: 25,
      size: 16777216,
      thresh: 20,
      grow: POOL,
      minDrawSize: 8,
      minstretch: 2,
      stretch: 6,
      colors: [darkBlueGreen, veryDarkYellow, darkerBlueGreen]
    }, {
      index: 24,
      size: 8388608,
      thresh: 16,
      grow: POOL,
      minDrawSize: 8,
      minstretch: 1,
      stretch: 4,
      colors: [darkForestGreen, darkBlueGreen]
    }, {
      index: 22,
      size: 2097152,
      thresh: 8,
      grow: POOL,
      minDrawSize: 4,
      minstretch: 1,
      stretch: 5,
      colors: [forestGreen, darkForestGreen]
    }, {
      index: 23,
      size: 4194304,
      thresh: 1,
      grow: POOL,
      minDrawSize: 4,
      minstretch: 1,
      stretch: 2,
      colors: [mBackground]
    }, {
      index: 19,
      size: 262144,
      thresh: 5,
      grow: CROSS,
      minDrawSize: 4,
      minstretch: 1,
      stretch: 5,
      colors: [mRed],
      outcolors: [sageStreak]
    }
  ];

  layerGroups = [waterGroup, outerGroup, buildingGroup, cityGroup];

  growSeed = function(c, x1, y1, scalex, scaley, rects, map, cy) {
    var abort, cellSize, cindex, colors, curx, cury, dual, gridPoint, i, inc, isVertical, j, l, main_rng, n, onCity, onOther, poolColor, r, rng, start, stopat, _i, _j, _k, _l, _len, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _results;
    colors = cy.colors;
    if (cy.grow === POOL) {
      main_rng = CustomRandom(c.x, c.y, cy.size);
      cindex = main_rng.next() % cy.colors.length;
      poolColor = colors[cindex];
      for (i = _i = _ref = 0 - c.extent1, _ref1 = c.extent2; _ref <= _ref1 ? _i < _ref1 : _i > _ref1; i = _ref <= _ref1 ? ++_i : --_i) {
        for (j = _j = _ref2 = 0 - c.extent1, _ref3 = c.extent2; _ref2 <= _ref3 ? _j < _ref3 : _j > _ref3; j = _ref2 <= _ref3 ? ++_j : --_j) {
          r = {};
          r.color = poolColor;
          r.rect = [(c.x - x1 + i * cy.size) * scalex, (c.y - y1 + j * cy.size) * scaley, cy.size * scalex, cy.size * scaley];
          rects.push(r);
          rememberCellProperty(map, c.x + i * cy.size, c.y + j * cy.size, cy.size, "active", true);
        }
      }
    }
    if (cy.grow === CLOUD) {
      main_rng = CustomRandom(c.x, c.y, cy.size);
      cindex = main_rng.next() % cy.colors.length;
      poolColor = colors[cindex];
      for (i = _k = _ref4 = 0 - c.extent1, _ref5 = c.extent2; _ref4 <= _ref5 ? _k < _ref5 : _k > _ref5; i = _ref4 <= _ref5 ? ++_k : --_k) {
        curx = c.x + i * cy.size;
        for (j = _l = _ref6 = 0 - c.extent1, _ref7 = c.extent2; _ref6 <= _ref7 ? _l < _ref7 : _l > _ref7; j = _ref6 <= _ref7 ? ++_l : --_l) {
          cury = c.y + i * cy.size;
          abort = false;
          rng = CustomRandom(curx, cury, cy.size);
          n = main_rng.next();
          if (n > cy.cloudThresh) {
            abort = true;
          }
          if (!abort && cy.index >= 11 && cy.index <= 19) {
            gridPoint = getPointAlignedToGrid(curx, cury, 4194304);
            onCity = recallCellProperty(map, gridPoint[0], gridPoint[1], 4194304, "active");
            if (onCity) {
              for (l = _m = 12; _m <= 18; l = ++_m) {
                if (abort) {
                  break;
                }
                cellSize = indexSizeTable[l];
                gridPoint = getPointAlignedToGrid(curx, cury, cellSize);
                onOther = recallCellProperty(map, gridPoint[0], gridPoint[1], cellSize, "active");
                if (onOther) {
                  abort = true;
                }
              }
            }
          }
          if (!abort) {
            r = {};
            cindex = rng.next() % cy.colors.length;
            r.color = cy.colors[cindex];
            r.rect = [(c.x - x1 + i * cy.size) * scalex, (c.y - y1 + j * cy.size) * scaley, cy.size * scalex, cy.size * scaley];
            rects.push(r);
            rememberCellProperty(map, c.x + i * cy.size, c.y + j * cy.size, cy.size, "active", true);
          }
        }
      }
    }
    if (cy.grow === CROSS || (cy.grow === LINE)) {
      _ref8 = [true, false];
      _results = [];
      for (_n = 0, _len = _ref8.length; _n < _len; _n++) {
        isVertical = _ref8[_n];
        if (cy.grow === LINE && isVertical !== c.dir) {
          continue;
        }
        _results.push((function() {
          var _o, _results1;
          _results1 = [];
          for (dual = _o = 0; _o < 2; dual = ++_o) {
            abort = false;
            start = 0;
            inc = 1;
            stopat = c.extent1;
            if (dual > 0) {
              start = -1;
              inc = -1;
              stopat = 0 - c.extent2;
            }
            _results1.push((function() {
              var _p, _q, _results2;
              _results2 = [];
              for (i = _p = start; inc > 0 ? _p < stopat : _p > stopat; i = _p += inc) {
                colors = cy.colors;
                rng;
                curx;
                cury;
                if (isVertical) {
                  curx = c.x + i * cy.size;
                  cury = c.y;
                } else {
                  curx = c.x;
                  cury = c.y + i * cy.size;
                }
                rng = CustomRandom(curx, cury, cy.size);
                r = {};
                cindex = rng.next() % cy.colors.length;
                if (cy.index >= 11 && cy.index <= 19) {
                  gridPoint = getPointAlignedToGrid(curx, cury, 4194304);
                  onCity = recallCellProperty(map, gridPoint[0], gridPoint[1], 4194304, "active");
                  if (onCity) {
                    for (l = _q = 11; _q <= 18; l = ++_q) {
                      if (abort) {
                        break;
                      }
                      cellSize = indexSizeTable[l];
                      gridPoint = getPointAlignedToGrid(curx, cury, cellSize);
                      onOther = recallCellProperty(map, gridPoint[0], gridPoint[1], cellSize, "active");
                      if (onOther) {
                        abort = true;
                      }
                    }
                  }
                  if (cy.index === 19 || cy.index === 18) {
                    if (onCity && cy.index === 19) {
                      abort = true;
                    }
                    if (!onCity) {
                      colors = cy.outcolors;
                    }
                  }
                }
                if (!abort) {
                  r.color = colors[cindex];
                  r.rect = [(curx - x1) * scalex, (cury - y1) * scaley, cy.size * scalex, cy.size * scaley];
                  rects.push(r);
                  _results2.push(rememberCellProperty(map, curx, cury, cy.size, "active", true));
                } else {
                  _results2.push(void 0);
                }
              }
              return _results2;
            })());
          }
          return _results1;
        })());
      }
      return _results;
    }
  };

  getRectsIn = function(x1, y1, x2, y2, s) {
    var Nthresh, c, cellSkip, cy, dx, dy, grid, gridPoint, hs, i, j, lg, map, maxstretch, n, rects, rng, runlist, runner, scalex, scaley, size, stepx, stepy, xmax, xmin, ymax, ymin, _i, _j, _k, _l, _len, _len1, _len2, _m, _ref, _ref1;
    rects = [];
    hs = s / 2;
    if (x2 < x1) {
      _ref = [x2, x1], x1 = _ref[0], x2 = _ref[1];
    }
    scalex = s / (x2 - x1);
    scaley = s / (y2 - y1);
    map = {};
    for (_i = 0, _len = layerGroups.length; _i < _len; _i++) {
      lg = layerGroups[_i];
      runlist = SortedList.create({
        compare: function(a, b) {
          if (a.tstart !== b.tstart) {
            return a.tstart - b.tstart;
          }
          if (a.x !== b.x) {
            return a.x - b.x;
          }
          return a.y - b.y;
        }
      });
      for (_j = 0, _len1 = lg.length; _j < _len1; _j++) {
        cy = lg[_j];
        if (cy.size * scalex < cy.minDrawSize) {
          continue;
        }
        maxstretch = cy.stretch;
        gridPoint = getPointAlignedToGrid(x1, y1, cy.size);
        dx = cy.size;
        dy = cy.size;
        size = cy.size;
        xmin = gridPoint[0] - (maxstretch * dx);
        ymin = gridPoint[1] - (maxstretch * dy);
        gridPoint = getPointAlignedToGrid(x2, y2, cy.size);
        xmax = gridPoint[0] + (maxstretch * dx) + dx;
        ymax = gridPoint[1] + (maxstretch * dy) + dy;
        c = {};
        grid = new Array((xmax - xmin) / dx);
        Nthresh = cy.thresh;
        stepx = 0;
        for (i = _k = xmin; dx > 0 ? _k < xmax : _k > xmax; i = _k += dx) {
          grid[stepx] = new Array((ymax - ymin) / dy);
          stepy = 0;
          for (j = _l = ymin; dy > 0 ? _l < ymax : _l > ymax; j = _l += dy) {
            cellSkip = false;
            if (!cellSkip && cy.index === 27) {
              gridPoint = getPointAlignedToGrid(i, j, 134217728);
              if (!recallCellProperty(map, gridPoint[0], gridPoint[1], 134217728, "active")) {
                cellSkip = true;
              }
            }
            if (!cellSkip && cy.index < 27) {
              gridPoint = getPointAlignedToGrid(i, j, 134217728);
              if (recallCellProperty(map, gridPoint[0], gridPoint[1], 134217728, "active")) {
                cellSkip = true;
              }
            }
            if (!cellSkip && cy.index > 20 && cy.index < 23) {
              gridPoint = getPointAlignedToGrid(i, j, 4194304);
              if (recallCellProperty(map, gridPoint[0], gridPoint[1], 4194304, "active")) {
                cellSkip = true;
              }
            }
            if (!cellSkip && cy.index < 18) {
              gridPoint = getPointAlignedToGrid(i, j, 4194304);
              if (!recallCellProperty(map, gridPoint[0], gridPoint[1], 4194304, "active")) {
                cellSkip = true;
              }
            }
            if (!cellSkip) {
              rng = CustomRandom(i, j, cy.size);
              n = rng.next();
              if (n < Nthresh) {
                c = {};
                c.cy = cy;
                c.x = i;
                c.y = j;
                c.size = scalex;
                c.dir = (_ref1 = rng.next() < 512) != null ? _ref1 : {
                  0: 1
                };
                c.tstart = rng.next();
                c.extent1 = cy.minstretch + rng.next().mod(cy.stretch - cy.minstretch);
                c.extent2 = cy.minstretch + rng.next().mod(cy.stretch - cy.minstretch);
                grid[stepx][stepy] = c;
                runlist.insert(c);
              }
            }
            stepy += 1;
          }
          stepx += 1;
        }
      }
      for (_m = 0, _len2 = runlist.length; _m < _len2; _m++) {
        runner = runlist[_m];
        growSeed(runner, x1, y1, scalex, scaley, rects, map, runner.cy);
      }
    }
    return rects;
  };

  tiles = new L.TileLayer.Canvas({
    continuousWorld: true
  });

  tiles.drawTile = function(canvas, tile, zoom) {
    var MaxX, MaxY, MinX, MinY, XDiff, XStart, YDiff, YStart, ctx, r, rects, tileCount, _i, _len, _results;
    analytics.track('DrawTile', {
      x: tile.x,
      y: tile.y,
      zoom: zoom
    });
    ctx = canvas.getContext('2d');
    ctx.fillStyle = darkBackground;
    ctx.fillRect(0, 0, 256, 256);
    ctx.fillStyle = 'black';
    tileCount = 1 << zoom;
    XStart = 0;
    XDiff = 268435456;
    MinX = XStart + XDiff * tile.x / tileCount;
    MaxX = MinX + XDiff / tileCount;
    YStart = 0;
    YDiff = 268435456;
    MinY = YStart + YDiff * tile.y / tileCount;
    MaxY = MinY + YDiff / tileCount;
    rects = getRectsIn(MinX, MinY, MaxX, MaxY, 256);
    _results = [];
    for (_i = 0, _len = rects.length; _i < _len; _i++) {
      r = rects[_i];
      ctx.fillStyle = r.color;
      _results.push(ctx.fillRect.apply(ctx, r.rect));
    }
    return _results;
  };

  defaultStart = {
    center: new L.LatLng(584.8926, 1106.5347),
    zoom: 10
  };

  start = L.Hash.prototype.parseHash(location.hash) || defaultStart;

  this.map = new L.Map('map', {
    center: start.center,
    zoom: start.zoom,
    minZoom: 0,
    maxZoom: 14,
    layers: [tiles],
    attributionControl: false,
    crs: L.CRS.Simple
  });

  hash = new L.Hash(map);

  analytics.track('Running', {});

  attrib = new L.Control.Attribution;

  attrib.setPrefix("");

  attrStr = '<a href="#" onclick="javascript:clickDemo();">tour</a> | ';

  attrStr += '<a href="#" onclick="javascript:clickHome();">home</a> | ';

  attrStr += '<a href="https://github.com/dribnet/victory/">code</a>';

  attrib.addAttribution(attrStr);

  map.addControl(attrib);

  curLinkIndex = 1;

  linkPath = ["#10/584.8931/1106.5347", "#9/584.885/1106.920", "#7/584.398/1107.727", "#4/581.66/1111.84", "#0/572.1/1127.6", "#0/448/1374", "#2/398.4/1492.8", "#4/376.78/1544.72", "#6/369.914/1552.977", "#8/369.908/1552.982", "#10/370.0034/1552.8345", "#12/370.0756/1552.8522", "#9/370.0752/1552.8545", "#5/370.078/1552.859", "#1/370/1553", "#1/186/1521", "#3/156.6/1558.0", "#5/148.141/1580.500", "#7/148.129/1580.500", "#10/147.8325/1580.6621", "#10/147.5903/1580.8340", "#10/147.0483/1581.2158", "#10/146.8130/1581.2773", "#7/147.145/1580.320", "#4/148.66/1575.88", "#1/167/1536", "#0/403/1158", "#2/584.8931/1106.5347", "#7/584.8931/1106.5347"];

  this.clickHome = function() {
    analytics.track('ClickHome', {});
    curLinkIndex = 0;
    location.hash = linkPath[0];
    return hash.update();
  };

  this.clickDemo = function() {
    analytics.track('ClickTour', {
      index: curLinkIndex
    });
    curLinkIndex = (curLinkIndex + 1) % linkPath.length;
    location.hash = linkPath[curLinkIndex];
    console.log("at " + curLinkIndex + " of " + linkPath.length);
    return hash.update();
  };

  this.debugBack = function() {
    curLinkIndex = (curLinkIndex + linkPath.length - 1) % linkPath.length;
    location.hash = linkPath[curLinkIndex];
    console.log("at " + curLinkIndex + " of " + linkPath.length);
    return hash.update();
  };

}).call(this);
